{"ast":null,"code":"import { Contract, ethers } from \"ethers\";\nimport * as chains from \"./constants/chains\";\nimport COINS from \"./constants/coins\";\nimport WalletConnectProvider from \"@walletconnect/web3-provider\";\n\nconst ROUTER = require(\"./build/UniswapV2Router02.json\");\n\nconst ERC20 = require(\"./build/ERC20.json\");\n\nconst FACTORY = require(\"./build/IUniswapV2Factory.json\");\n\nconst PAIR = require(\"./build/IUniswapV2Pair.json\");\n\nexport async function getProvider() {\n  //  Create WalletConnect Provider\n  const provider = new WalletConnectProvider({\n    infuraId: \"bcf29fbf63f041a09c778e222624d390\",\n    rpc: {\n      1: \"https://mainnet.mycustomnode.com\",\n      3: \"https://ropsten.mycustomnode.com\",\n      100: \"https://dai.poa.network\" // ...\n\n    }\n  }); //  Enable session (triggers QR Code modal)\n\n  await provider.enable();\n  return new ethers.providers.Web3Provider(provider);\n}\nexport function getSigner(provider) {\n  return provider.getSigner();\n}\nexport async function getNetwork(provider) {\n  const network = await provider.getNetwork();\n  return network.chainId;\n}\nexport function getRouter(address, signer) {\n  return new Contract(address, ROUTER.abi, signer);\n}\nexport async function checkNetwork(provider) {\n  const chainId = getNetwork(provider);\n\n  if (chains.networks.includes(chainId)) {\n    return true;\n  }\n\n  return false;\n}\nexport function getWeth(address, signer) {\n  return new Contract(address, ERC20.abi, signer);\n}\nexport function getFactory(address, signer) {\n  return new Contract(address, FACTORY.abi, signer);\n}\nexport async function getAccount() {\n  const accounts = await window.ethereum.request({\n    method: \"eth_requestAccounts\"\n  });\n  return accounts[0];\n} //This function checks if a ERC20 token exists for a given address\n//    `address` - The Ethereum address to be checked\n//    `signer` - The current signer\n\nexport function doesTokenExist(address, signer) {\n  try {\n    return new Contract(address, ERC20.abi, signer);\n  } catch (err) {\n    return false;\n  }\n}\nexport async function getDecimals(token) {\n  const decimals = await token.decimals().then(result => {\n    return result;\n  }).catch(error => {\n    console.log(\"No tokenDecimals function for this token, set to 0\");\n    return 0;\n  });\n  return decimals;\n} // This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\n//    `provider` - The current provider\n//    `signer` - The current signer\n\nexport async function getBalanceAndSymbol(accountAddress, address, provider, signer, weth_address, coins) {\n  try {\n    if (address === weth_address) {\n      const balanceRaw = await provider.getBalance(accountAddress);\n      return {\n        balance: ethers.utils.formatEther(balanceRaw),\n        symbol: coins[0].abbr\n      };\n    } else {\n      const token = new Contract(address, ERC20.abi, signer);\n      const tokenDecimals = await getDecimals(token);\n      const balanceRaw = await token.balanceOf(accountAddress);\n      const symbol = await token.symbol();\n      return {\n        balance: balanceRaw * 10 ** -tokenDecimals,\n        symbol: symbol\n      };\n    }\n  } catch (error) {\n    console.log(\"The getBalanceAndSymbol function had an error!\");\n    console.log(error);\n    return false;\n  }\n} // This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\n// No error handling is done, so any issues can be caught with the use of .catch()\n// To work correctly, there needs to be 7 arguments:\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `amount` - A float or similar number representing the value of address1's token to trade\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `signer` - The current signer\n\nexport async function swapTokens(address1, address2, amount, routerContract, accountAddress, signer) {\n  const tokens = [address1, address2];\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const tokenDecimals = await getDecimals(token1);\n  const amountIn = ethers.utils.parseUnits(amount, tokenDecimals);\n  const amountOut = await routerContract.callStatic.getAmountsOut(amountIn, tokens);\n  await token1.approve(routerContract.address, amountIn);\n  const wethAddress = await routerContract.WETH();\n\n  if (address1 === wethAddress) {\n    // Eth -> Token\n    await routerContract.swapExactETHForTokens(amountOut[1], tokens, accountAddress, deadline, {\n      value: amountIn\n    });\n  } else if (address2 === wethAddress) {\n    // Token -> Eth\n    await routerContract.swapExactTokensForETH(amountIn, amountOut[1], tokens, accountAddress, deadline);\n  } else {\n    await routerContract.swapExactTokensForTokens(amountIn, amountOut[1], tokens, accountAddress, deadline);\n  }\n} //This function returns the conversion rate between two token addresses\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\n//    `amountIn` - Amount of the token at address 1 to be swaped from\n//    `routerContract` - The router contract to carry out this swap\n\nexport async function getAmountOut(address1, address2, amountIn, routerContract, signer) {\n  try {\n    const token1 = new Contract(address1, ERC20.abi, signer);\n    const token1Decimals = await getDecimals(token1);\n    const token2 = new Contract(address2, ERC20.abi, signer);\n    const token2Decimals = await getDecimals(token2);\n    const values_out = await routerContract.getAmountsOut(ethers.utils.parseUnits(String(amountIn), token1Decimals), [address1, address2]);\n    const amount_out = values_out[1] * 10 ** -token2Decimals;\n    console.log(\"amount out: \", amount_out);\n    return Number(amount_out);\n  } catch {\n    return false;\n  }\n} // This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\n//    `pair` - The pair contract for the two tokens\n\nexport async function fetchReserves(address1, address2, pair, signer) {\n  try {\n    // Get decimals for each coin\n    const coin1 = new Contract(address1, ERC20.abi, signer);\n    const coin2 = new Contract(address2, ERC20.abi, signer);\n    const coin1Decimals = await getDecimals(coin1);\n    const coin2Decimals = await getDecimals(coin2); // Get reserves\n\n    const reservesRaw = await pair.getReserves(); // Put the results in the right order\n\n    const results = [(await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1], (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0]]; // Scale each to the right decimal place\n\n    return [results[0] * 10 ** -coin1Decimals, results[1] * 10 ** -coin2Decimals];\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0];\n  }\n} // This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `factory` - The current factory\n//    `signer` - The current signer\n\nexport async function getReserves(address1, address2, factory, signer, accountAddress) {\n  try {\n    const pairAddress = await factory.getPair(address1, address2);\n    const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n    if (pairAddress !== \"0x0000000000000000000000000000000000000000\") {\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer);\n      const liquidityTokens_BN = await pair.balanceOf(accountAddress);\n      const liquidityTokens = Number(ethers.utils.formatEther(liquidityTokens_BN));\n      return [reservesRaw[0].toPrecision(6), reservesRaw[1].toPrecision(6), liquidityTokens];\n    } else {\n      console.log(\"no reserves yet\");\n      return [0, 0, 0];\n    }\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0, 0];\n  }\n}","map":{"version":3,"sources":["/Users/lelouch/Desktop/ethnyc/eth-nyc-global/Alternative-Uniswap-Interface/src/ethereumFunctions.js"],"names":["Contract","ethers","chains","COINS","WalletConnectProvider","ROUTER","require","ERC20","FACTORY","PAIR","getProvider","provider","infuraId","rpc","enable","providers","Web3Provider","getSigner","getNetwork","network","chainId","getRouter","address","signer","abi","checkNetwork","networks","includes","getWeth","getFactory","getAccount","accounts","window","ethereum","request","method","doesTokenExist","err","getDecimals","token","decimals","then","result","catch","error","console","log","getBalanceAndSymbol","accountAddress","weth_address","coins","balanceRaw","getBalance","balance","utils","formatEther","symbol","abbr","tokenDecimals","balanceOf","swapTokens","address1","address2","amount","routerContract","tokens","time","Math","floor","Date","now","deadline","BigNumber","from","token1","amountIn","parseUnits","amountOut","callStatic","getAmountsOut","approve","wethAddress","WETH","swapExactETHForTokens","value","swapExactTokensForETH","swapExactTokensForTokens","getAmountOut","token1Decimals","token2","token2Decimals","values_out","String","amount_out","Number","fetchReserves","pair","coin1","coin2","coin1Decimals","coin2Decimals","reservesRaw","getReserves","results","token0","factory","pairAddress","getPair","liquidityTokens_BN","liquidityTokens","toPrecision"],"mappings":"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","sourcesContent":["import { Contract, ethers } from \"ethers\";\nimport * as chains from \"./constants/chains\";\nimport COINS from \"./constants/coins\";\nimport WalletConnectProvider from \"@walletconnect/web3-provider\";\n\nconst ROUTER = require(\"./build/UniswapV2Router02.json\");\nconst ERC20 = require(\"./build/ERC20.json\");\nconst FACTORY = require(\"./build/IUniswapV2Factory.json\");\nconst PAIR = require(\"./build/IUniswapV2Pair.json\");\n\nexport async function getProvider() {\n  //  Create WalletConnect Provider\n  const provider = new WalletConnectProvider({\n    infuraId: \"bcf29fbf63f041a09c778e222624d390\",\n    rpc: {\n      1: \"https://mainnet.mycustomnode.com\",\n      3: \"https://ropsten.mycustomnode.com\",\n      100: \"https://dai.poa.network\",\n      // ...\n    },\n  });\n\n  //  Enable session (triggers QR Code modal)\n  await provider.enable();\n\n  return new ethers.providers.Web3Provider(provider);\n}\n\nexport function getSigner(provider) {\n  return provider.getSigner();\n}\n\nexport async function getNetwork(provider) {\n  const network = await provider.getNetwork();\n  return network.chainId;\n}\n\nexport function getRouter(address, signer) {\n  return new Contract(address, ROUTER.abi, signer);\n}\n\nexport async function checkNetwork(provider) {\n  const chainId = getNetwork(provider);\n  if (chains.networks.includes(chainId)) {\n    return true;\n  }\n  return false;\n}\n\nexport function getWeth(address, signer) {\n  return new Contract(address, ERC20.abi, signer);\n}\n\nexport function getFactory(address, signer) {\n  return new Contract(address, FACTORY.abi, signer);\n}\n\nexport async function getAccount() {\n  const accounts = await window.ethereum.request({\n    method: \"eth_requestAccounts\",\n  });\n\n  return accounts[0];\n}\n\n//This function checks if a ERC20 token exists for a given address\n//    `address` - The Ethereum address to be checked\n//    `signer` - The current signer\nexport function doesTokenExist(address, signer) {\n  try {\n    return new Contract(address, ERC20.abi, signer);\n  } catch (err) {\n    return false;\n  }\n}\n\nexport async function getDecimals(token) {\n  const decimals = await token\n    .decimals()\n    .then((result) => {\n      return result;\n    })\n    .catch((error) => {\n      console.log(\"No tokenDecimals function for this token, set to 0\");\n      return 0;\n    });\n  return decimals;\n}\n\n// This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function getBalanceAndSymbol(\n  accountAddress,\n  address,\n  provider,\n  signer,\n  weth_address,\n  coins\n) {\n  try {\n    if (address === weth_address) {\n      const balanceRaw = await provider.getBalance(accountAddress);\n\n      return {\n        balance: ethers.utils.formatEther(balanceRaw),\n        symbol: coins[0].abbr,\n      };\n    } else {\n      const token = new Contract(address, ERC20.abi, signer);\n      const tokenDecimals = await getDecimals(token);\n      const balanceRaw = await token.balanceOf(accountAddress);\n      const symbol = await token.symbol();\n\n      return {\n        balance: balanceRaw * 10 ** -tokenDecimals,\n        symbol: symbol,\n      };\n    }\n  } catch (error) {\n    console.log(\"The getBalanceAndSymbol function had an error!\");\n    console.log(error);\n    return false;\n  }\n}\n\n// This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\n// No error handling is done, so any issues can be caught with the use of .catch()\n// To work correctly, there needs to be 7 arguments:\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `amount` - A float or similar number representing the value of address1's token to trade\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `signer` - The current signer\nexport async function swapTokens(\n  address1,\n  address2,\n  amount,\n  routerContract,\n  accountAddress,\n  signer\n) {\n  const tokens = [address1, address2];\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const tokenDecimals = await getDecimals(token1);\n\n  const amountIn = ethers.utils.parseUnits(amount, tokenDecimals);\n  const amountOut = await routerContract.callStatic.getAmountsOut(\n    amountIn,\n    tokens\n  );\n\n  await token1.approve(routerContract.address, amountIn);\n  const wethAddress = await routerContract.WETH();\n\n  if (address1 === wethAddress) {\n    // Eth -> Token\n    await routerContract.swapExactETHForTokens(\n      amountOut[1],\n      tokens,\n      accountAddress,\n      deadline,\n      { value: amountIn }\n    );\n  } else if (address2 === wethAddress) {\n    // Token -> Eth\n    await routerContract.swapExactTokensForETH(\n      amountIn,\n      amountOut[1],\n      tokens,\n      accountAddress,\n      deadline\n    );\n  } else {\n    await routerContract.swapExactTokensForTokens(\n      amountIn,\n      amountOut[1],\n      tokens,\n      accountAddress,\n      deadline\n    );\n  }\n}\n\n//This function returns the conversion rate between two token addresses\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\n//    `amountIn` - Amount of the token at address 1 to be swaped from\n//    `routerContract` - The router contract to carry out this swap\nexport async function getAmountOut(\n  address1,\n  address2,\n  amountIn,\n  routerContract,\n  signer\n) {\n  try {\n    const token1 = new Contract(address1, ERC20.abi, signer);\n    const token1Decimals = await getDecimals(token1);\n\n    const token2 = new Contract(address2, ERC20.abi, signer);\n    const token2Decimals = await getDecimals(token2);\n\n    const values_out = await routerContract.getAmountsOut(\n      ethers.utils.parseUnits(String(amountIn), token1Decimals),\n      [address1, address2]\n    );\n    const amount_out = values_out[1] * 10 ** -token2Decimals;\n    console.log(\"amount out: \", amount_out);\n    return Number(amount_out);\n  } catch {\n    return false;\n  }\n}\n\n// This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\n//    `pair` - The pair contract for the two tokens\nexport async function fetchReserves(address1, address2, pair, signer) {\n  try {\n    // Get decimals for each coin\n    const coin1 = new Contract(address1, ERC20.abi, signer);\n    const coin2 = new Contract(address2, ERC20.abi, signer);\n\n    const coin1Decimals = await getDecimals(coin1);\n    const coin2Decimals = await getDecimals(coin2);\n\n    // Get reserves\n    const reservesRaw = await pair.getReserves();\n\n    // Put the results in the right order\n    const results = [\n      (await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1],\n      (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0],\n    ];\n\n    // Scale each to the right decimal place\n    return [\n      results[0] * 10 ** -coin1Decimals,\n      results[1] * 10 ** -coin2Decimals,\n    ];\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0];\n  }\n}\n\n// This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `factory` - The current factory\n//    `signer` - The current signer\nexport async function getReserves(\n  address1,\n  address2,\n  factory,\n  signer,\n  accountAddress\n) {\n  try {\n    const pairAddress = await factory.getPair(address1, address2);\n    const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n    if (pairAddress !== \"0x0000000000000000000000000000000000000000\") {\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer);\n      const liquidityTokens_BN = await pair.balanceOf(accountAddress);\n      const liquidityTokens = Number(\n        ethers.utils.formatEther(liquidityTokens_BN)\n      );\n\n      return [\n        reservesRaw[0].toPrecision(6),\n        reservesRaw[1].toPrecision(6),\n        liquidityTokens,\n      ];\n    } else {\n      console.log(\"no reserves yet\");\n      return [0, 0, 0];\n    }\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0, 0];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}